//{{NodeBuilder Code Wizard Start <CodeWizard Timestamp>
// Run on Mon Oct 07 10:18:26 2013, version 4.01.07
//
//}}NodeBuilder Code Wizard End
//{{NodeBuilder Code Wizard Start <CodeWizard Template>
//// <Template Revision="3"/>
//}}NodeBuilder Code Wizard End
//////////////////////////////////////////////////////////////////////////////
// File: lon_cover.nc
//
//
// Generated by NodeBuilder Code Wizard Version 4.01.07
// Copyright (c) 2001-2009 Echelon Corporation.  All rights reserved.
//
// ECHELON MAKES NO REPRESENTATION, WARRANTY, OR CONDITION OF
// ANY KIND, EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE OR IN
// ANY COMMUNICATION WITH YOU, INCLUDING, BUT NOT LIMITED TO,
// ANY IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY
// QUALITY, FITNESS FOR ANY PARTICULAR PURPOSE,
// NONINFRINGEMENT, AND THEIR EQUIVALENTS.
//
//
// Written By:
//
// Description:
//
// lon_cover.nc is the device's main Neuron C source file, which
// automatically includes other application-specific Neuron C source or header
// files as necessary. The lon_cover.nc file also contains the
// system tasks (when(reset), etc), network variables and the file directory.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _lon_cover_NC_
#define _lon_cover_NC_

#define _CODEWIZARD_VERSION_3_TEMPLATES_

/////////////////////////////////////////////////////////////////////////////
// Connect with the Code Wizard library.
//
// Version 3 of these templates, released with NodeBuilder 4, introduce
// versioning to the CodeWizard library by name. While version 1 didn't use
// any library, version 2 references CodeWizard.lib. This release of the
// templates, revision 3, references CodeWizard-3.lib, thus supporting
// co-existence of both template versions 2 and 3.
//
// The CodeWizard library supplies most of the utility functions defined in
// CodeWizard.h. Source code for this library is available in your
// NodeBuilder\Templates\CodeWizard\vX\LibSrc folder within your local
// LonWorks folder, where 'vX' is v2 or v3 (v4, etc, in future versions),
// subject to  the revision number of this application framework template.
// The revision number of this application framework template can be found
// at the top of this file.
//
// By default, CodeWizard-3.lib will be pre-installed into your LonWorks\images
// folder, and can be referenced with the pragma library "$IMG$\CodeWizard-3.lib"
// directive.
// User-defined versions of CodeWizard-3.lib should be located elsewhere. Define
// the USER_DEFINED_CODEWIZARD_LIB macro in this case, and reference your own
// version of CodeWizard-3.lib through the NodeBuilder project manager or the
// pragma library directive. See Readme.txt in the library source code folder
// for considerations and instructions regarding rebuilding of this library.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef  _NEURONC
#   ifndef _MODEL_FILE
#       ifndef USER_DEFINED_CODEWIZARD_LIB
#           pragma library "$IMG$\CodeWizard-3.lib"
#       endif // USER_DEFINED_CODEWIZARD_LIB
#    endif // _MODEL_FILE
#endif  // _NEURONC

/////////////////////////////////////////////////////////////////////////////
// Header Files
//
#include "lon_cover.h"
#include "common.h"
#include "macros.h"

//
// The FileDirectory variable contains the file directory. Please see
// filexfer.h and filesys.h for more details about the implementation of the
// file system and the file transfer protocol.
// Note a file directory must be defined whenever at least one configuration
// property is defined in a configuration property value file, or at least one
// user-defined file exists. A file directory must be defined independent of
// the CP access mechanism (file transfer or direct access).
// Note that a different layout of file directory will be compiled for each of
// these access methods. The two access methods are mutually exclusive.
//
#ifndef _USE_NO_CPARAMS_ACCESS
    DIRECTORY_STORAGE TFileDirectory FileDirectory = {
        FILE_DIRECTORY_VERSION,   // major and minor version number (one byte)
        NUM_FILES, {
#ifdef _USE_DIRECT_CPARAMS_ACCESS
            { cp_template_file_len,         TEMPLATE_TYPE,  cp_template_file },
            { cp_modifiable_value_file_len, VALUE_TYPE,     cp_modifiable_value_file },
            { cp_readonly_value_file_len,   VALUE_TYPE,     cp_readonly_value_file   }
#else   // def. _USE_FTP_CPARAMS_ACCESS
            { NULL_INFO, { 0ul, cp_template_file_len         },    TEMPLATE_TYPE, cp_template_file },
            { NULL_INFO, { 0ul, cp_modifiable_value_file_len },    VALUE_TYPE,    cp_modifiable_value_file },
            { NULL_INFO, { 0ul, cp_readonly_value_file_len   },    VALUE_TYPE,    cp_readonly_value_file }
#endif  // def. _USE_DIRECT_CPARAMS_ACCESS
        }
    };
#endif // def. _USE_NO_CPARAMS_ACCESS

//{{NodeBuilder Code Wizard Start
// The NodeBuilder Code Wizard will add and remove code here.
// DO NOT EDIT the NodeBuilder Code Wizard generated code in these blocks
// between {{NodeBuilder Code Wizard Start and }}NodeBuilder Code Wizard End

//<Include Enum Type Headers>
//
//<Global CP Family Declarations>
//
//<Include Headers>
#include "NodeObject.h"
//
//<Device CP Family Declarations>
//
//<Device CP Declarations>
//
//<Device Input NV Declarations>
//
//<Device Output NV Declarations>
//
// <Include NC>
#include "NodeObject.nc"
//
//}}NodeBuilder Code Wizard End


/////////////////////////////////////////////////////////////////////////////
// Neuron C Files
//
#include "common.nc"

#ifdef _USE_FTP_CPARAMS_ACCESS
    #include "fileSys.nc"
    #include "fileXfer.nc"
#endif

//{{NodeBuilder Code Wizard Start
// The NodeBuilder Code Wizard will add and remove code here.
// DO NOT EDIT the NodeBuilder Code Wizard generated code in these blocks!

//<Input NV>
//
//}}NodeBuilder Code Wizard End

//{{NodeBuilder Code Wizard Start
// The NodeBuilder Code Wizard will add and remove code here.
// DO NOT EDIT the NodeBuilder Code Wizard generated code in these blocks!

//<Input NV Define>
//
// The following code will be ignored if this Neuron C file is used without
// an input NV implemented.  The Code Wizard automatically enables
// the _HAS_INP_DEV_NV macro if there is at least one input NV implemented.
//
#ifdef _HAS_INP_DEV_NV
//
//<Device NV When>
//
//}}NodeBuilder Code Wizard End
{
    // TODO: Add code to handle input network variable processing
}
#endif  //_HAS_INP_DEV_NV

//
// when(reset) executes when the device is reset. Make sure to keep
// your when(reset) task short, as a pending state change can not be
// confirmed until this task is completed.
// The executeOnEachFblock() function, which is part of the CodeWizard
// application framework and can be found in the common.nc source file,
// automatically re-triggers the watchdog timer with every 16th fblock, but
// time-consuming director implementations may require additional caution
// in this regard.
//

#include <float.h>
#include <io_types.h>
#include "iec103.h"

IO_8 input serial baud(4800) IOcharIn; // serial input device
IO_10 output serial baud(4800) IOcharOut;

stimer repeating tim;

far Record package_tx;
far Record package_rx;

network input SNVT_time_stamp nviLastTiming;

network input SNVT_count nviAddressRs485;
network input SNVT_switch nviCoverControl;

network output SNVT_angle_f nvoTiltValue;
network output SNVT_count nvoTiltCount;
network output SNVT_switch nvoTiltAlarm;

network output SNVT_press_f nvoHitValue;
network output SNVT_count nvoHitCount;

network output SNVT_switch nvoLocked;
network output SNVT_count nvoUnlockedCount;

network output SNVT_switch nvoActive;
network output SNVT_date_time nvoUpdateOn;

eeprom uint8_t eepAddress;

void handlePackage(void);

//
// when(reset) executes when the device is reset. Make sure to keep
// your when(reset) task short, as a pending state change can not be
// confirmed until this task is completed.
// The executeOnEachFblock() function, which is part of the CodeWizard
// application framework and can be found in the common.nc source file,
// automatically re-triggers the watchdog timer with every 16th fblock, but
// time-consuming director implementations may require additional caution
// in this regard.
//
when (reset) {
    initAllFblockData(TOTAL_FBLOCK_COUNT);
    executeOnEachFblock(0, FBC_WHEN_RESET);
    nviAddressRs485 = eepAddress;
    tim = 2;
}

when (nv_update_occurs(nviAddressRs485)) {
    eepAddress = (uint8_t)nviAddressRs485;
}

void inquire() {
    uint8_t length, cs_recv, cs_calc, i;
    setFrame10(&package_tx, 0x5b, (uint8_t)nviAddressRs485);
    io_out(IOcharOut, package_tx.buff, package_tx.length);
    clear(&package_tx);

    do {
        length = io_in(IOcharIn, package_rx.buff, 4);
        if (length != 4) break;
        if (package_rx.buff[0] != 0x68 || package_rx.buff[3] != 0x68) break;
        if (package_rx.buff[1] != package_rx.buff[2]) break;

        package_rx.length = length;

        length = io_in(IOcharIn, package_rx.buff + 4, package_rx.buff[1] + 2);
        if (length != package_rx.buff[1] + 2) break;
        if (package_rx.buff[package_rx.buff[1] + 5] != 0x16) break;
        if (package_rx.buff[5] != (uint8_t)nviAddressRs485) break;

        for (cs_calc = 0, i = 0; i < package_rx.buff[1]; i++)
            cs_calc += *(package_rx.buff + 4 + i);
        cs_recv = package_rx.buff[package_rx.buff[1]+4];

        if (cs_calc != cs_recv) break;

        package_rx.length += length;

        nvoActive.state = 1;

        handlePackage();
        return;

    } while (FALSE);

    nvoActive.state = 0;
}

far const uint8_t ASDU_HEAD_6804[6] = {0x06, 0x81, 0x08, 0xff, 0xff, 0x00};
far const uint8_t ASDU_HEAD_OPEN[8] = {0x40, 0x05, 0x0c, 0x01, 0x12, 0x70, 0x00, 0x00};
far const uint8_t ASDU_HEAD_CLOSE[8] = {0x40, 0x05, 0x0c, 0x01, 0x12, 0x71, 0x00, 0x00};

when (nv_update_occurs(nviCoverControl)) {
	uint8_t length;
    tim = 0;

    initFrame68(&package_tx, 0x53, (uint8_t)nviAddressRs485);

    if (nviCoverControl.state)
        appendFrame68(&package_tx, ASDU_HEAD_OPEN, 8);
    else
        appendFrame68(&package_tx, ASDU_HEAD_CLOSE, 8);

    completeFrame68(&package_tx);
    io_out(IOcharOut, package_tx.buff, package_tx.length);

    length = io_in(IOcharIn, package_rx.buff, 5);

    if (length < 5)
        nvoActive.state = 0;

    tim = 2;
}

when (nv_update_occurs(nviLastTiming)){
    tim = 0;

    initFrame68(&package_tx, 0x44, (uint8_t)nviAddressRs485);
    appendFrame68(&package_tx, ASDU_HEAD_6804, 6);
    appendByteToFrame68(&package_tx, (uint8_t)((nviLastTiming.second * 1000) & 0xff));
    appendByteToFrame68(&package_tx, (uint8_t)((nviLastTiming.second * 1000) >> 8));
    appendByteToFrame68(&package_tx, (uint8_t)nviLastTiming.minute);
    appendByteToFrame68(&package_tx, (uint8_t)nviLastTiming.hour);
    appendByteToFrame68(&package_tx, (uint8_t)nviLastTiming.day);
    appendByteToFrame68(&package_tx, (uint8_t)nviLastTiming.month);
    appendByteToFrame68(&package_tx, (uint8_t)nviLastTiming.year & 0x7f);
    completeFrame68(&package_tx);

    io_out(IOcharOut, package_tx.buff, package_tx.length);
    tim = 2;
}

when (timer_expires(tim)) {
    inquire();
}

void getReversedS32(s32_type *s, uint8_t *p) {
    s->bytes[3] = p[0];
    s->bytes[2] = p[1];
    s->bytes[1] = p[2];
    s->bytes[0] = p[3];
}

void handlePackage() {
    s32_type s;
    uint8_t i;
    static uint8_t has_event;
    boolean got_hit, got_tilt, got_open;
    nvoActive.state = 1;

    switch (package_rx.buff[1]) {
    case 0x1a:
        has_event = 0;
        getReversedS32(&s, package_rx.buff + 14);
        nvoTiltValue = *(SNVT_angle_f *)(&s);

        getReversedS32(&s, package_rx.buff + 20);
        nvoHitValue = *(SNVT_press_f *)(&s);

        nvoTiltAlarm.state = package_rx.buff[26] & 0x02 ? 1 : 0;
        nvoLocked.state = package_rx.buff[26] & 0x04 ? 1 : 0;

        break;
    case 0x13:
    case 0x1d:
    case 0x27:
        has_event = 1;

        got_hit = FALSE;
        got_tilt = FALSE;
        got_open = FALSE;

        i = 13;
        while (i + 10 < package_rx.length) {
            switch (package_rx.buff[i]) {
                case 0x01:
                    nvoHitCount = package_rx.buff[i + 5];
                    getReversedS32(&s, package_rx.buff + i + 6);
                    nvoHitValue = *(SNVT_press_f *)(&s);
                    got_hit = TRUE;
                    break;
                case 0x02:
                    nvoTiltCount = package_rx.buff[i + 5];
                    getReversedS32(&s, package_rx.buff + i + 6);
                    nvoTiltValue = *(SNVT_angle_f *)(&s);
                    got_tilt = TRUE;
                    break;
                case 0x03:
                    nvoUnlockedCount = package_rx.buff[i + 5];
                    nvoLocked.state = 0;
                    got_open = TRUE;
                    break;
            }
            i += 10;
        }

        if (!got_hit) nvoHitCount = 0;
        if (!got_tilt) nvoTiltCount = 0;
        if (!got_open) nvoUnlockedCount = 0;

        nvoUpdateOn.second = package_rx.buff[15];
        nvoUpdateOn.minute = package_rx.buff[16];
        nvoUpdateOn.hour = package_rx.buff[17];

        break;
    }

    if (has_event) {
        inquire();
    }
}

//
// when(offline) executes as the device enters the offline state.
// Make sure to keep this task short, as the state change can
// not be confirmed until this task is completed.
//
when (offline)
{
    executeOnEachFblock(0, FBC_WHEN_OFFLINE);
}

//
// when(online) executes as the device enters the online state.
// Make sure to keep this task short, as the state change can
// not be confirmed until this task is completed.
//
when (online)
{
    executeOnEachFblock(0, FBC_WHEN_ONLINE);
}

//
// when(wink) executes as the device receives a wink command, and regardless
// of the device's current state. Add code here to implement your device's
// specific wink-behavior. Your code should trigger an appropriate action,
// such as the brief flashing of an LED or the sounding of a buzzer, allowing
// maintenance staff to identify the device in the field.
// Under no circumstances should wink cause an action that could engage users,
// machinery or maintenance staff.
// Remember the wink task also executes in the unconfigured state. Application
// timers and other features that require the configured state should not be
// used in the implementation of your when(wink) task.
//
when (wink)
{
    // TODO: Implement appropriate wink behavior here
}


#ifdef _HAS_CHANGEABLE_NV

//
// CodeWizard automatically defines the _HAS_CHANGEABLE_NV macro, if at least
// one network variable with changeable type is implemented. The conditionally
// compiled code here implements the system callback routine used to report
// the true and current length of a given network variable back to the system
// firmware.
// Code Wizard also enables the callback by inserting the
// system_image_extensions pragma, see lon_cover.h.
// Note that callback support requires version 14 system firmware (or better).
//
unsigned get_nv_length_override(unsigned nvIndex)
{
    unsigned uResult;

    // Assume no override
    uResult = 0xFF;

    // TO DO: add code to return the current length of the network variable
    // with index "nvIndex."
    // Example code follows:
    //
    // switch (nvIndex) {
    //     case nviChangeableNv::global_index:
    //         if (nviChangeableNv::cpNvType.type_category != NVT_CAT_INITIAL
    //          && nviChangeableNv::cpNvType.type_category != NVT_CAT_NUL) {
    //             uResult = nviChangeableNv::cpNvType.type_length;
    //         }
    //         break;
    // } // switch

    return uResult;
}

#endif  // #ifdef _HAS_CHANGEABLE_NV
#endif // _lon_cover_NC_
